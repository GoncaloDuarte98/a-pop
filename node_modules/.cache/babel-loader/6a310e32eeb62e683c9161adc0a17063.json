{"ast":null,"code":"// New Changes are done in order to use the subscription tool!\nimport ApolloClient from \"apollo-client\";\nimport { WebSocketLink } from \"apollo-link-ws\";\nimport { InMemoryCache } from \"apollo-cache-inmemory\";\nimport { gql } from \"apollo-boost\";\nimport { GET_PLAYLIST_SONGS } from \"./queries\"; // import ApolloClient from 'apollo-boost'\n\nconst client = new ApolloClient({\n  link: new WebSocketLink({\n    uri: \"wss://zepta-music.herokuapp.com/v1/graphql\",\n    options: {\n      //Connects whenever it's possible\n      reconnect: true\n    }\n  }),\n  cache: new InMemoryCache(),\n  // This has been done by hasura previously, creating these typeDefs for us\n  // , creating these shema's for us  but now we need to tell apollo\n  // what we quering for, the data itself or any mutations\n  typeDefs: gql`\n    type Song {\n      id: uuid!\n      thumbnail: String!\n      artist: String!\n      title: String!\n      duration: Float!\n      url: String!\n    }\n\n    input SongInput {\n      id: uuid!\n      thumbnail: String!\n      artist: String!\n      title: String!\n      duration: Float!\n      url: String!\n    }\n\n    type Query {\n      playlist: [Song]!\n    }\n\n    type Mutation {\n      addOrRemoveFromPlaylist(input: SongInput!): [Song]!\n    }\n  `,\n  // returns array of type song\n  // So we defined to apollo, what exactly our song data woulb be consists of,\n  // how to query the data and how to make mutations to it\n  // Tells how our mutations and queries resolve!\n  resolvers: {\n    Mutation: {\n      // We're gonna specify how the data we got recieved on input\n      // is gonna turn into array into array of Songs!\n      addOrRemoveFromPlaylist: (_, {\n        input\n      }, {\n        cache\n      }) => {\n        const queryResult = cache.readQuery({\n          query: GET_PLAYLIST_SONGS\n        });\n\n        if (queryResult) {\n          const {\n            playlist\n          } = queryResult; //checking where the particular song already resides in playlist or not\n\n          const isInPlaylist = playlist.some(song => song.id === input.id);\n          const newPlaylist = isInPlaylist ? playlist.filter(song => song.id !== input.id) : [...playlist, input]; // Add input in the very end!\n          // add it in the end of the queue\n\n          cache.writeQuery({\n            query: GET_PLAYLIST_SONGS,\n            data: {\n              playlist: newPlaylist\n            }\n          });\n          return newPlaylist;\n        }\n\n        return [];\n      }\n    }\n  }\n});\nconst hasPlaylist = Boolean(localStorage.getItem(\"playlist\")); // taken from local storage and put them in a cache, queried using a\n// local query and put in the Playlist component!\n\nconst data = {\n  playlist: hasPlaylist ? JSON.parse(localStorage.getItem(\"playlist\")) : []\n}; // the way through which we give the created client the data\n\nclient.writeData({\n  data\n}); // const client = new ApolloClient( {\n//     uri: 'https://zepta-music.herokuapp.com/v1/graphql'\n// })\n\nexport default client;","map":{"version":3,"sources":["/home/goncalo/Desktop/FirstTimers/a-pop/src/graphql/client.js"],"names":["ApolloClient","WebSocketLink","InMemoryCache","gql","GET_PLAYLIST_SONGS","client","link","uri","options","reconnect","cache","typeDefs","resolvers","Mutation","addOrRemoveFromPlaylist","_","input","queryResult","readQuery","query","playlist","isInPlaylist","some","song","id","newPlaylist","filter","writeQuery","data","hasPlaylist","Boolean","localStorage","getItem","JSON","parse","writeData"],"mappings":"AAAA;AACA,OAAOA,YAAP,MAAyB,eAAzB;AACA,SAASC,aAAT,QAA8B,gBAA9B;AACA,SAASC,aAAT,QAA8B,uBAA9B;AACA,SAASC,GAAT,QAAoB,cAApB;AACA,SAASC,kBAAT,QAAmC,WAAnC,C,CAEA;;AAEA,MAAMC,MAAM,GAAG,IAAIL,YAAJ,CAAiB;AAC9BM,EAAAA,IAAI,EAAE,IAAIL,aAAJ,CAAkB;AACtBM,IAAAA,GAAG,EAAE,4CADiB;AAEtBC,IAAAA,OAAO,EAAE;AACP;AACAC,MAAAA,SAAS,EAAE;AAFJ;AAFa,GAAlB,CADwB;AAQ9BC,EAAAA,KAAK,EAAE,IAAIR,aAAJ,EARuB;AAS9B;AACA;AACA;AAEAS,EAAAA,QAAQ,EAAER,GAAI;;;;;;;;;;;;;;;;;;;;;;;;;;GAbgB;AAwC9B;AACA;AACA;AACA;AACAS,EAAAA,SAAS,EAAE;AACTC,IAAAA,QAAQ,EAAE;AACR;AACA;AACAC,MAAAA,uBAAuB,EAAE,CAACC,CAAD,EAAI;AAAEC,QAAAA;AAAF,OAAJ,EAAe;AAAEN,QAAAA;AAAF,OAAf,KAA6B;AACpD,cAAMO,WAAW,GAAGP,KAAK,CAACQ,SAAN,CAAgB;AAClCC,UAAAA,KAAK,EAAEf;AAD2B,SAAhB,CAApB;;AAGA,YAAIa,WAAJ,EAAiB;AACf,gBAAM;AAAEG,YAAAA;AAAF,cAAeH,WAArB,CADe,CAEf;;AACA,gBAAMI,YAAY,GAAGD,QAAQ,CAACE,IAAT,CAAeC,IAAD,IAAUA,IAAI,CAACC,EAAL,KAAYR,KAAK,CAACQ,EAA1C,CAArB;AACA,gBAAMC,WAAW,GAAGJ,YAAY,GAC5BD,QAAQ,CAACM,MAAT,CAAiBH,IAAD,IAAUA,IAAI,CAACC,EAAL,KAAYR,KAAK,CAACQ,EAA5C,CAD4B,GAE5B,CAAC,GAAGJ,QAAJ,EAAcJ,KAAd,CAFJ,CAJe,CAMW;AAC1B;;AACAN,UAAAA,KAAK,CAACiB,UAAN,CAAiB;AACfR,YAAAA,KAAK,EAAEf,kBADQ;AAEfwB,YAAAA,IAAI,EAAE;AAAER,cAAAA,QAAQ,EAAEK;AAAZ;AAFS,WAAjB;AAIA,iBAAOA,WAAP;AACD;;AACD,eAAO,EAAP;AACD;AAtBO;AADD;AA5CmB,CAAjB,CAAf;AAwEA,MAAMI,WAAW,GAAGC,OAAO,CAACC,YAAY,CAACC,OAAb,CAAqB,UAArB,CAAD,CAA3B,C,CACA;AACA;;AACA,MAAMJ,IAAI,GAAG;AACXR,EAAAA,QAAQ,EAAES,WAAW,GAAGI,IAAI,CAACC,KAAL,CAAWH,YAAY,CAACC,OAAb,CAAqB,UAArB,CAAX,CAAH,GAAkD;AAD5D,CAAb,C,CAIA;;AACA3B,MAAM,CAAC8B,SAAP,CAAiB;AAAEP,EAAAA;AAAF,CAAjB,E,CAEA;AACA;AACA;;AAEA,eAAevB,MAAf","sourcesContent":["// New Changes are done in order to use the subscription tool!\nimport ApolloClient from \"apollo-client\";\nimport { WebSocketLink } from \"apollo-link-ws\";\nimport { InMemoryCache } from \"apollo-cache-inmemory\";\nimport { gql } from \"apollo-boost\";\nimport { GET_PLAYLIST_SONGS } from \"./queries\";\n\n// import ApolloClient from 'apollo-boost'\n\nconst client = new ApolloClient({\n  link: new WebSocketLink({\n    uri: \"wss://zepta-music.herokuapp.com/v1/graphql\",\n    options: {\n      //Connects whenever it's possible\n      reconnect: true,\n    },\n  }),\n  cache: new InMemoryCache(),\n  // This has been done by hasura previously, creating these typeDefs for us\n  // , creating these shema's for us  but now we need to tell apollo\n  // what we quering for, the data itself or any mutations\n\n  typeDefs: gql`\n    type Song {\n      id: uuid!\n      thumbnail: String!\n      artist: String!\n      title: String!\n      duration: Float!\n      url: String!\n    }\n\n    input SongInput {\n      id: uuid!\n      thumbnail: String!\n      artist: String!\n      title: String!\n      duration: Float!\n      url: String!\n    }\n\n    type Query {\n      playlist: [Song]!\n    }\n\n    type Mutation {\n      addOrRemoveFromPlaylist(input: SongInput!): [Song]!\n    }\n  `,\n  // returns array of type song\n  // So we defined to apollo, what exactly our song data woulb be consists of,\n  // how to query the data and how to make mutations to it\n  // Tells how our mutations and queries resolve!\n  resolvers: {\n    Mutation: {\n      // We're gonna specify how the data we got recieved on input\n      // is gonna turn into array into array of Songs!\n      addOrRemoveFromPlaylist: (_, { input }, { cache }) => {\n        const queryResult = cache.readQuery({\n          query: GET_PLAYLIST_SONGS,\n        });\n        if (queryResult) {\n          const { playlist } = queryResult;\n          //checking where the particular song already resides in playlist or not\n          const isInPlaylist = playlist.some((song) => song.id === input.id);\n          const newPlaylist = isInPlaylist\n            ? playlist.filter((song) => song.id !== input.id)\n            : [...playlist, input]; // Add input in the very end!\n          // add it in the end of the queue\n          cache.writeQuery({\n            query: GET_PLAYLIST_SONGS,\n            data: { playlist: newPlaylist },\n          });\n          return newPlaylist;\n        }\n        return [];\n      },\n    },\n  },\n});\n\nconst hasPlaylist = Boolean(localStorage.getItem(\"playlist\"));\n// taken from local storage and put them in a cache, queried using a\n// local query and put in the Playlist component!\nconst data = {\n  playlist: hasPlaylist ? JSON.parse(localStorage.getItem(\"playlist\")) : [],\n};\n\n// the way through which we give the created client the data\nclient.writeData({ data });\n\n// const client = new ApolloClient( {\n//     uri: 'https://zepta-music.herokuapp.com/v1/graphql'\n// })\n\nexport default client;\n"]},"metadata":{},"sourceType":"module"}